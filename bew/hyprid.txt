Perfect—here’s a drop-in step that matches your pipeline shape.

# src/steps/hybrid_search_impls/HybridSearchV1.py
from __future__ import annotations
from pathlib import Path
from typing import Dict, List
import json

from src.steps.hybrid_search_impls.CHybridSearchABS import hybridSearch
from src.pipeline.Context import Context
from src.utils.logging import get_logger


class HybridSearchV1(hybridSearch):
    """
    Reads vector + bm25 result JSONs and fuses them with RRF.
    Output JSON mirrors your existing structure and is written to
    cfg.paths.hybrid_results_path. Also sets ctx.artifacts['hybrid_results_path'].
    """

    name = "hybridSearchV1"

    def run(self, ctx: Context) -> None:
        log = get_logger(self.name)

        # --- Config / paths ---
        paths = ctx.cfg.get("paths", {}) or {}
        vec_path = Path(paths.get("vector_results_path", "./Daten/workspace/vector_results.json"))
        bm25_path = Path(paths.get("bm25_results_path", "./Daten/workspace/bm25_results.json"))
        out_path = Path(paths.get("hybrid_results_path", "./Daten/workspace/hybrid_results.json"))

        rrf_cfg = ctx.cfg.get("rrf", {}) or {}
        K = int(rrf_cfg.get("K", 60))
        wvec = float(rrf_cfg.get("weights", {}).get("vector", 1.0))
        wbm  = float(rrf_cfg.get("weights", {}).get("bm25", 1.0))
        topk = int(ctx.cfg.get("query", {}).get("k", 10))

        # --- Load legs ---
        def _load(p: Path) -> List[dict]:
            if not p.exists():
                log.warning("Results file missing: %s", p)
                return []
            try:
                return json.loads(p.read_text(encoding="utf-8")).get("results", [])
            except Exception as e:
                log.error("Failed to read %s: %s", p, e)
                return []

        vec = _load(vec_path)
        bm  = _load(bm25_path)
        if not vec and not bm:
            log.error("No inputs for hybrid fusion.")
            return

        # --- Rank maps (key by chunkname to avoid doc_id mismatches) ---
        def _ranks(items: List[dict], score_key: str) -> Dict[str, int]:
            items = [x for x in items if score_key in x.get("scores", {})]
            items.sort(key=lambda x: x["scores"][score_key], reverse=True)
            return {x["chunkname"]: i + 1 for i, x in enumerate(items)}

        r_vec = _ranks(vec, "vector")
        r_bm  = _ranks(bm, "bm25")

        # --- Union of candidates + metadata representative ---
        keys = set(r_vec) | set(r_bm)
        meta: Dict[str, dict] = {}
        for item in vec + bm:
            meta.setdefault(item["chunkname"], item)

        # --- RRF fusion ---
        def rrf_score(kname: str) -> float:
            s = 0.0
            if kname in r_vec:
                s += wvec * 1.0 / (K + r_vec[kname])
            if kname in r_bm:
                s += wbm  * 1.0 / (K + r_bm[kname])
            return s

        fused = []
        for kname in keys:
            m = meta[kname]
            fused.append({
                "doc_id": m.get("doc_id"),
                "chunkname": kname,
                "filename_txt": m.get("filename_txt", ""),
                "file_path_html": m.get("file_path_html", ""),
                "scores": {
                    "rrf": rrf_score(kname),
                    "vector_rank": r_vec.get(kname),
                    "bm25_rank": r_bm.get(kname),
                },
            })

        fused.sort(key=lambda x: x["scores"]["rrf"], reverse=True)
        output = {
            "query": ctx.artifacts.get("corrected_query")
                     or ctx.cfg.get("query", {}).get("text", ""),
            "results": fused[:topk],
        }

        # --- Write + artifacts ---
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(json.dumps(output, ensure_ascii=False, indent=2), encoding="utf-8")
        ctx.artifacts["hybrid_results_path"] = str(out_path)
        log.info("Hybrid (RRF) top %d written to %s", len(output["results"]), out_path)

Minimal YAML

paths:
  vector_results_path: ./Daten/workspace/vector_results.json
  bm25_results_path:   ./Daten/workspace/bm25_results.json
  hybrid_results_path: ./Daten/workspace/hybrid_results.json

rrf:
  K: 60
  weights:
    vector: 1.0
    bm25: 1.0

query:
  k: 10

Run your vector step → BM25 step → HybridSearchV1. The output JSON is your fused top-K with scores.rrf plus each leg’s rank for debugging.

